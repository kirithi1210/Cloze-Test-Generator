# -*- coding: utf-8 -*-
"""Untitled24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18ll1jRf9TPVsOm2G5oAUVueTIXENyZQ5
"""

!pip install -q transformers spacy torch gradio

# Download the small English model for spaCy
!python -m spacy download en_core_web_sm

from __future__ import annotations
import argparse
import json
import sys
from pathlib import Path
from typing import Dict, List, Sequence, Tuple

import torch
import spacy
from transformers import AutoModelForMaskedLM, AutoTokenizer, pipeline

try:
    import gradio as gr
except ImportError:
    gr = None


class ClozeGenerator:
    def __init__(self, model_name: str = "bert-base-uncased", nlp_model: str = "en_core_web_sm", device: int = -1):
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModelForMaskedLM.from_pretrained(model_name)
        self.fill_mask = pipeline("fill-mask", model=self.model, tokenizer=self.tokenizer, device=device)

        try:
            self.nlp = spacy.load(nlp_model)
        except OSError:
            import subprocess
            subprocess.run([sys.executable, "-m", "spacy", "download", nlp_model], check=True)
            self.nlp = spacy.load(nlp_model)

    def generate(
        self,
        text: str,
        num_blanks: int = 5,
        difficulty: str = "medium",
        pos_targets: Sequence[str] | None = None,
        avoid_ner: bool = True,
    ) -> Tuple[str, Dict[str, str]]:
        doc = self.nlp(text)
        candidates = self._select_tokens(doc, pos_targets, avoid_ner)
        if not candidates:
            raise ValueError("No suitable tokens to blank out.")
        if num_blanks > len(candidates):
            num_blanks = len(candidates)
        scored = self._score_tokens(text, candidates)
        if difficulty == "easy":
            scored.sort(key=lambda s: s.score, reverse=True)
        elif difficulty == "hard":
            scored.sort(key=lambda s: s.score)
        else:
            scored.sort(key=lambda s: abs(0.5 - s.score))
        chosen = {s.token.i for s in scored[:num_blanks]}
        return self._build_output(doc, chosen)

    class _Scored:
        def __init__(self, token: spacy.tokens.Token, score: float):
            self.token = token
            self.score = score

    def _select_tokens(self, doc: spacy.tokens.Doc, pos_targets: Sequence[str] | None, avoid_ner: bool):
        pos_targets = {p.lower() for p in pos_targets} if pos_targets else {"nouns", "verbs", "adjectives"}
        pos_map = {"NOUN": "nouns", "PROPN": "nouns", "VERB": "verbs", "ADJ": "adjectives"}

        def valid(tok: spacy.tokens.Token) -> bool:
            if not tok.is_alpha or tok.is_stop:
                return False
            if pos_map.get(tok.pos_) not in pos_targets:
                return False
            if avoid_ner and tok.ent_type_:
                return False
            return len(self.tokenizer.tokenize(tok.text)) == 1

        return [tok for tok in doc if valid(tok)]

    def _score_tokens(self, text: str, toks: List[spacy.tokens.Token], top_k: int = 5):
        mask = self.tokenizer.mask_token
        scored = []
        for tok in toks:
            masked = text[: tok.idx] + mask + text[tok.idx + len(tok.text):]
            try:
                preds = self.fill_mask(masked, top_k=top_k)
            except RuntimeError:
                preds = []
            score = 0.0
            for p in preds:
                if p["token_str"].strip().lower() == tok.text.lower():
                    score = p["score"]
                    break
            scored.append(self._Scored(tok, score))
        return scored

    def _build_output(self, doc: spacy.tokens.Doc, blank_ids: set[int]) -> Tuple[str, Dict[str, str]]:
        parts = []
        answers = {}
        idx = 1
        for tok in doc:
            if tok.i in blank_ids:
                parts.append(f"___({idx})___")
                answers[str(idx)] = tok.text
                idx += 1
            else:
                parts.append(tok.text)
            parts.append(tok.whitespace_)
        return "".join(parts).strip(), answers

    @staticmethod
    def export_to_json(path: Path, quiz: str, ans: Dict[str, str]) -> None:
        with open(path, "w", encoding="utf-8") as f:
            json.dump({"quiz": quiz, "answers": ans}, f, indent=2, ensure_ascii=False)

    @staticmethod
    def build_arg_parser() -> argparse.ArgumentParser:
        p = argparse.ArgumentParser(description="Generate cloze tests from text")
        p.add_argument("--text", required=True, help="Input passage")
        p.add_argument("--num_blanks", type=int, default=5)
        p.add_argument("--difficulty", choices=["easy", "medium", "hard"], default="medium")
        p.add_argument("--pos_targets", nargs="*", default=["nouns", "verbs", "adjectives"], help="Parts of speech to blank")
        p.add_argument("--no_ner", action="store_true", help="Allow blanking named entities")
        p.add_argument("--export_json", type=Path, help="Save quiz + answers to JSON file")
        return p


def build_demo() -> "gradio.Blocks":
    if gr is None:
        raise ImportError("Install gradio to use the web interface: pip install gradio")
    gen = ClozeGenerator()

    def _gen(text, num, diff, pos, avoid):
        pos = None if "all" in [x.lower() for x in pos] else pos
        quiz, ans = gen.generate(text, num_blanks=num, difficulty=diff, pos_targets=pos, avoid_ner=avoid)
        ans_str = "\n".join(f"{k}. {v}" for k, v in ans.items())
        return quiz, ans_str

    with gr.Blocks() as demo:
        gr.Markdown("# üìù Cloze Test Generator")
        text = gr.Textbox(label="Input Passage", lines=8)
        num = gr.Slider(1, 20, value=5, step=1, label="Number of blanks")
        diff = gr.Radio(["easy", "medium", "hard"], value="medium", label="Difficulty")
        pos = gr.CheckboxGroup(["nouns", "verbs", "adjectives"], value=["nouns", "verbs", "adjectives"], label="POS targets")
        ner = gr.Checkbox(value=True, label="Avoid named entities")
        btn = gr.Button("Generate")
        quiz = gr.Textbox(lines=8, label="Cloze Passage")
        ans = gr.Textbox(lines=8, label="Answer Key")
        btn.click(_gen, [text, num, diff, pos, ner], [quiz, ans])
        gr.Markdown("Built with spaCy + Transformers + Gradio")
    return demo


if __name__ == "__main__":
    try:
        if gr is None:
            print("Gradio is not installed. Please run: pip install gradio")
        else:
            demo = build_demo()
            demo.launch(share=True)
    except Exception as e:
        print("Error launching Gradio UI:", e)
        print("Falling back to CLI mode.")
        parser = ClozeGenerator.build_arg_parser()
        args = parser.parse_args()
        gen = ClozeGenerator()
        pos = None if "all" in [p.lower() for p in args.pos_targets] else args.pos_targets
        quiz, answers = gen.generate(
            args.text,
            num_blanks=args.num_blanks,
            difficulty=args.difficulty,
            pos_targets=pos,
            avoid_ner=not args.no_ner,
        )
        print("\nCloze Quiz:\n" + quiz)
        print("\nAnswer Key:")
        for k, v in answers.items():
            print(f"{k}. {v}")
        if args.export_json:
            ClozeGenerator.export_to_json(args.export_json, quiz, answers)
            print(f"\nSaved to {args.export_json.resolve()}")